{"version":3,"file":"plugins/582.js","mappings":"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","sources":["webpack://services-comun/./modules/utiles/stream.ts","webpack://services-comun/./modules/utiles/fs.ts","webpack://services-comun/./modules/utiles/hash.ts","webpack://services-comun/./modules/utiles/log.ts","webpack://services-comun/./modules/utiles/random.ts","webpack://services-comun/./tools/src/mrpack/clases/comando.ts","webpack://services-comun/./tools/src/mrpack/clases/yarn.ts"],"sourcesContent":["import { pipeline, Readable } from \"node:stream\";\nimport { promisify } from \"node:util\";\nconst pipelinePromise = promisify(pipeline);\nexport { pipelinePromise as pipeline };\nexport function buffer2stream(binary) {\n    return new Readable({\n        read() {\n            this.push(binary);\n            this.push(null);\n        },\n    });\n}\nexport async function stream2buffer(data) {\n    return new Promise((resolve) => {\n        const chunks = [];\n        data.on(\"data\", (chunk) => {\n            chunks.push(chunk);\n        }).on(\"end\", () => {\n            resolve(Buffer.concat(chunks));\n        });\n    });\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport { readFileSync } from \"node:fs\";\nimport { existsSync, statSync } from \"node:fs\";\nimport { mkdir as mkdirOriginal, readdir, readFile, rename as renameOriginal, rm, stat } from \"node:fs/promises\";\nimport { error, warning } from \"./log\";\nimport { md5 } from \"./hash\";\nimport { pipeline } from \"./stream\";\nimport { random } from \"./random\";\nexport async function exists(file) {\n    return new Promise((resolve) => {\n        fs.access(file, fs.constants.F_OK, (err) => {\n            resolve(!err);\n        });\n    });\n}\nexport { readdir as readDir, readFile, stat as stats, };\nexport async function readFileBuffer(file) {\n    return readFile(file);\n}\nexport async function readFileString(file) {\n    const data = await readFile(file);\n    return data.toString(\"utf-8\");\n}\nexport async function fileSize(file) {\n    const stats = await stat(file);\n    return stats.size;\n}\nexport async function readJSON(file) {\n    try {\n        const buffer = await readFileString(file);\n        return JSON.parse(buffer);\n    }\n    catch (e) {\n        return Promise.reject(e);\n    }\n}\nexport function readJSONSync(file) {\n    try {\n        return JSON.parse(readFileSync(file).toString(\"utf-8\"));\n    }\n    catch (e) {\n        return null;\n    }\n}\nexport async function isDir(dir, excepcion = false) {\n    try {\n        const stats = await stat(dir);\n        if (stats.isDirectory()) {\n            return true;\n        }\n    }\n    catch (e) { }\n    if (!excepcion) {\n        return false;\n    }\n    return Promise.reject(\"Not a directory\");\n}\nexport async function isFile(file, excepcion = false) {\n    try {\n        const stats = await stat(file);\n        if (stats.isFile()) {\n            return true;\n        }\n    }\n    catch (e) { }\n    if (!excepcion) {\n        return false;\n    }\n    return Promise.reject(\"Not a file\");\n}\nexport function isFileSync(file) {\n    return existsSync(file) && statSync(file).isFile();\n}\nexport async function mkdir(dir, recursive = false) {\n    await mkdirOriginal(dir, {\n        recursive: recursive\n    });\n}\nexport async function rename(antiguo, nuevo) {\n    return renameOriginal(antiguo, nuevo)\n        .then(() => true)\n        .catch(() => false);\n}\nexport async function rmdir(path) {\n    await rm(path, {\n        recursive: true,\n        force: true,\n    });\n    // return new Promise<void>((resolve: Function)=>{\n    //     child_process.exec(`rm -R ${path}`, () => {\n    //         resolve();\n    //     });\n    // });\n}\nexport async function rmDirManual(path) {\n    if (await isDir(path)) {\n        for (const actual of await readdir(path)) {\n            await rmDirManual(`${path}/${actual}`);\n        }\n    }\n    await unlink(path);\n}\nexport async function overwrite(oldPath, newPath, sobreescribir) {\n    if (!sobreescribir) {\n        if (await exists(newPath)) {\n            await unlink(oldPath);\n            return false;\n        }\n    }\n    if (!await rename(oldPath, newPath)) {\n        await unlink(oldPath);\n    }\n    return true;\n}\nexport async function safeWrite(local, data, sobreescribir = false, excepcion = false) {\n    const rnd = `${local}.${random()}`;\n    return new Promise((resolve, reject) => {\n        fs.writeFile(rnd, data, {\n            flag: \"wx\",\n        }, (err) => {\n            if (!err) {\n                overwrite(rnd, local, sobreescribir).then((ok) => {\n                    if (ok) {\n                        resolve(true);\n                    }\n                    else {\n                        if (!excepcion) {\n                            resolve(false);\n                        }\n                        else {\n                            reject(\"No se pudo renombrar el archivo temporal al final\");\n                        }\n                    }\n                });\n            }\n            else {\n                if (!excepcion) {\n                    error(\"Error en safeWrite\", rnd, err);\n                    resolve(false);\n                }\n                else {\n                    reject(\"No se pudo escribir archivo temporal\");\n                }\n            }\n        });\n    });\n}\nexport async function safeWriteStream(inbound, local, sobreescribir = false) {\n    const rnd = `${local}.${random()}`;\n    return await pipeline(inbound, fs.createWriteStream(rnd, {\n        flags: \"wx\",\n    }))\n        .catch((err) => {\n        warning(`Error escribiendo temporal ${rnd}`, err);\n        return Promise.reject(err);\n    })\n        .then(async () => overwrite(rnd, local, sobreescribir))\n        .catch(async () => {\n        if (await isFile(rnd)) {\n            await unlink(rnd);\n        }\n        return false;\n    });\n}\nexport async function safeWriteStreamBuffer(inbound, local, sobreescribir = false) {\n    const buffer = [];\n    inbound.on(\"data\", (data) => {\n        buffer.push(data);\n    });\n    return new Promise((resolve) => {\n        inbound.on(\"end\", () => {\n            safeWrite(local, Buffer.concat(buffer), sobreescribir).then(() => {\n                resolve(true);\n            }).catch(() => {\n                resolve(false);\n            });\n        });\n        inbound.on(\"error\", () => {\n            resolve(false);\n        });\n        // inbound.on(\"error\", (err)=>{\n        //     warning(\"Error en safeWriteStreamBuffer\", err);\n        //     resolve();\n        // });\n    });\n}\nexport async function unlink(file) {\n    if (await isFile(file)) {\n        await new Promise((resolve, reject) => {\n            fs.unlink(file, (err) => {\n                if (!err) {\n                    resolve();\n                }\n                else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    else if (await isDir(file)) {\n        await rmdir(file);\n    }\n}\nexport async function findSubdirs(dir) {\n    const salida = [];\n    if (await isDir(dir)) {\n        salida.push(dir);\n        for (const item of await readdir(dir)) {\n            if (![\".\", \"..\"].includes(item)) {\n                salida.push(...await findSubdirs(`${dir}/${item}`));\n            }\n        }\n    }\n    return salida;\n}\nasync function md5DirExec(dir) {\n    const salida = [\n        md5(path.basename(dir)),\n    ];\n    if (await isFile(dir)) {\n        salida.push(md5(await readFileString(dir)));\n    }\n    else if (await isDir(dir)) {\n        for (const actual of await readdir(dir)) {\n            const name = `${dir}/${actual}`;\n            if (await isDir(name)) {\n                if (name != \"files\") {\n                    salida.push(await md5Dir(name));\n                }\n            }\n            else if (await isFile(name)) {\n                salida.push(md5(actual));\n                salida.push(md5(await readFileString(name)));\n            }\n        }\n    }\n    return salida.join(\"\");\n}\nexport async function md5Dir(dir) {\n    if (!await isFile(dir) && !await isDir(dir)) {\n        return \"\";\n    }\n    const salida = await md5DirExec(dir);\n    if (salida.length != 32) {\n        return md5(salida);\n    }\n    return salida;\n}\nexport async function md5File(file) {\n    if (!await isFile(file)) {\n        return \"\";\n    }\n    return md5(await readFileString(file));\n}\nexport async function freeSpace(path) {\n    return new Promise((resolve, reject) => {\n        fs.statfs(path, (err, stats) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(stats.bsize * stats.bavail);\n            }\n            // console.log('Total free space', formatMemoria(stats.bsize*stats.bfree));\n            // console.log('Available for user', formatMemoria(stats.bsize*stats.bavail));\n            // console.log(stats);\n        });\n    });\n}\n","import { createHash } from \"node:crypto\";\nexport function md5(entrada) {\n    return createHash('md5').update(entrada).digest(\"hex\");\n}\nexport function sha512(entrada) {\n    return createHash('sha512').update(entrada).digest(\"hex\");\n}\n","import os from \"node:os\";\nimport cluster from \"node:cluster\";\nconst KUBERNETES = process.env[\"KUBERNETES\"] == \"true\";\nfunction generarEstatico() {\n    const worker = cluster.worker?.id;\n    if (KUBERNETES) {\n        const partes = os.hostname().split(\"-\");\n        const last = partes.pop();\n        partes.pop(); // eliminamos el ID de despliegue\n        if (worker == undefined) {\n            return `[${partes.join(\"-\")} ${last}]`;\n        }\n        return `[${partes.join(\"-\")} ${last} {${worker}}]`;\n    }\n    if (worker == undefined) {\n        return ``;\n    }\n    return ` {${worker}}`;\n}\nconst ESTATICO = generarEstatico();\nexport function info(...txt) {\n    if (txt.length > 0) {\n        console.info(ESTATICO, ...txt);\n    }\n    else if (!KUBERNETES) {\n        console.info(\"\");\n    }\n}\nexport function warning(...txt) {\n    if (txt.length > 0) {\n        console.warn(ESTATICO, ...txt);\n    }\n    else if (!KUBERNETES) {\n        console.warn(\"\");\n    }\n}\nexport function error(...txt) {\n    if (txt.length > 0) {\n        console.error(ESTATICO, ...txt);\n    }\n    else if (!KUBERNETES) {\n        console.error(\"\");\n    }\n}\nexport function debug(...txt) {\n    if (txt.length > 0) {\n        console.debug(ESTATICO, ...txt);\n    }\n    else if (!KUBERNETES) {\n        console.debug(\"\");\n    }\n}\nexport function time(txt, previo = \"\") {\n    if (previo.length > 0) {\n        info(previo);\n    }\n    console.time(`${KUBERNETES ? \"\" : \"                      \"}=> ${txt}`);\n}\nexport function timeEnd(txt) {\n    info(`Fin de proceso: `);\n    console.timeEnd(`${KUBERNETES ? \"\" : \"                      \"}=> ${txt}`);\n}\nexport function formatMemoria(memoria) {\n    let unidad = \"B\";\n    if (Math.abs(memoria) > 1024) {\n        memoria = memoria / 1024;\n        unidad = \"KB\";\n    }\n    if (Math.abs(memoria) > 1024) {\n        memoria = memoria / 1024;\n        unidad = \"MB\";\n    }\n    if (Math.abs(memoria) > 1024) {\n        memoria = memoria / 1024;\n        unidad = \"GB\";\n    }\n    if (Math.abs(memoria) > 1024) {\n        memoria = memoria / 1024;\n        unidad = \"TB\";\n    }\n    return `${memoria.toFixed(2)}${unidad}`;\n}\nexport function formatTiempo(ms) {\n    let annos = 0;\n    let meses = 0;\n    let dias = 0;\n    let horas = 0;\n    let minutos = 0;\n    let segundos = 0;\n    ms = Math.floor(ms);\n    if (ms > 1000) {\n        segundos = Math.floor(ms / 1000);\n        ms = ms % 1000;\n    }\n    if (segundos > 60) {\n        minutos = Math.floor(segundos / 60);\n        segundos = segundos % 60;\n    }\n    if (minutos > 60) {\n        horas = Math.floor(minutos / 60);\n        minutos = minutos % 60;\n    }\n    if (horas > 24) {\n        dias = Math.floor(horas / 24);\n        horas = horas % 24;\n    }\n    if (dias > 365) {\n        annos = Math.floor(dias / 365);\n        dias = dias % 365;\n    }\n    if (dias > 30) {\n        meses = Math.floor(dias / 30);\n        dias = dias % 30;\n    }\n    const salida = [];\n    if (annos > 0) {\n        salida.push(`${annos} año${annos == 1 ? \"\" : \"s\"}`);\n    }\n    if (meses > 0) {\n        salida.push(`${meses} mes${meses == 1 ? \"\" : \"es\"}`);\n    }\n    if (dias > 0) {\n        salida.push(`${dias} dia${dias == 1 ? \"\" : \"s\"}`);\n    }\n    if (horas > 0) {\n        salida.push(`${horas} hora${horas == 1 ? \"\" : \"s\"}`);\n    }\n    if (minutos > 0) {\n        salida.push(`${minutos} minuto${minutos == 1 ? \"\" : \"s\"}`);\n    }\n    if (segundos > 0) {\n        salida.push(`${segundos} segundo${segundos == 1 ? \"\" : \"s\"}`);\n    }\n    if (ms > 0) {\n        salida.push(`${ms} milisegundo${ms == 1 ? \"\" : \"s\"}`);\n    }\n    if (salida.length > 0) {\n        const ultimo = salida.pop();\n        if (salida.length > 0) {\n            return `${salida.join(\", \")} y ${ultimo}`;\n        }\n        return ultimo;\n    }\n    return \"0 milisegundos\";\n}\n","const letras = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\nfunction random(chars = 8) {\n    let salida = '';\n    for (let i = 0; i < chars; i++) {\n        salida += letras.charAt(Math.round(Math.random() * 62));\n    }\n    return salida;\n}\nfunction valoresValidos(listado) {\n    if (listado.length < 3) {\n        return [];\n    }\n    const minimo = listado.reduce((minimo, actual) => {\n        return actual < minimo ? actual : minimo;\n    });\n    const maximo = listado.reduce((maximo, actual) => {\n        return actual > maximo ? actual : maximo;\n    });\n    if (Math.abs(minimo - maximo) < 1) {\n        return listado;\n    }\n    const menores = [];\n    const mayores = [];\n    let medianos = false;\n    for (let actual of listado) {\n        const diferencia_menor = Math.abs(actual - minimo);\n        const diferencia_mayor = Math.abs(actual - maximo);\n        if (diferencia_menor < diferencia_mayor) {\n            menores.push(actual);\n        }\n        else if (diferencia_menor > diferencia_mayor) {\n            mayores.push(actual);\n        }\n        else {\n            medianos = true;\n            menores.push(actual);\n            mayores.push(actual);\n        }\n    }\n    if (medianos) {\n        return listado;\n    }\n    if (menores.length == 1) {\n        listado.splice(listado.indexOf(menores[0]), 1);\n    }\n    if (mayores.length == 1) {\n        listado.splice(listado.indexOf(mayores[0]), 1);\n    }\n    return listado;\n}\nexport { random, valoresValidos };\n","import { spawn } from \"node:child_process\";\nexport class Comando {\n    /* STATIC */\n    static async spawn(comando, params = [], { cwd, env = {}, shell = true, colores = true } = {}) {\n        const proceso = spawn(comando, params, {\n            cwd,\n            env: {\n                ...process.env,\n                ...env,\n                ...colores ? {\n                    FORCE_COLOR: \"1\",\n                } : {},\n            },\n            stdio: \"pipe\",\n            shell,\n        });\n        const stdout = [];\n        proceso.stdout.on(\"data\", (data) => {\n            stdout.push(data.toString(\"utf-8\"));\n        });\n        const stderr = [];\n        proceso.stderr.on(\"data\", (data) => {\n            stderr.push(data.toString(\"utf-8\"));\n        });\n        return new Promise((resolve) => {\n            proceso.on(\"close\", (status) => {\n                resolve({\n                    status: status ?? 0,\n                    stdout: stdout.join(\"\"),\n                    stderr: stderr.join(\"\"),\n                });\n            });\n        });\n    }\n}\n","import { spawn } from \"node:child_process\";\nimport { Colors } from \"./colors\";\nimport { Comando } from \"./comando\";\nimport { readFileBuffer, readFileString, safeWrite, unlink } from \"../../../../modules/utiles/fs\";\nexport class Yarn {\n    /* STATIC */\n    static async update(basedir, install) {\n        console.log(Colors.colorize([Colors.FgCyan, Colors.Bright], \"Actualizando YARN\"));\n        console.group();\n        const { anterior, nueva } = await this.updateBase(basedir);\n        const cambio = anterior != nueva;\n        const instalar = cambio || install;\n        if (cambio) {\n            await safeWrite(`${basedir}/${anterior}`, await readFileBuffer(`${basedir}/${nueva}`));\n            Colors.resetNext();\n            //     console.group();\n            //     await Promise.all([\n            //         this.updatePlugin(basedir, \"interactive-tools\"),\n            //         this.updatePlugin(basedir, \"typescript\"),\n            //         this.updatePlugin(basedir, \"workspace-tools\"),\n            //     ]);\n            //     console.groupEnd();\n            //     Colors.resetNext();\n            //     instalar = true;\n            // } else {\n            //     const plugins: Promise<void>[] = [];\n            //     const rc = await readFileString(`${basedir}/.yarnrc.yml`);\n            //     Colors.resetNext();\n            //     console.group();\n            //     if (!rc.includes(\"interactive-tools\")) {\n            //         plugins.push(this.updatePlugin(basedir, \"interactive-tools\"));\n            //     }\n            //     if (!rc.includes(\"typescript\")) {\n            //         plugins.push(this.updatePlugin(basedir, \"typescript\"));\n            //     }\n            //     if (!rc.includes(\"workspace-tools\")) {\n            //         plugins.push(this.updatePlugin(basedir, \"workspace-tools\"));\n            //     }\n            //     if (plugins.length>0) {\n            //         instalar = true;\n            //         await Promise.all(plugins);\n            //         console.groupEnd();\n            //         Colors.resetNext();\n            //     } else {\n            //         instalar = false;\n            //         console.groupEnd();\n            //     }\n        }\n        console.groupEnd();\n        if (instalar) {\n            await this.install(basedir, { verbose: false });\n        }\n        const lock1 = await readFileString(`${basedir}/yarn.lock`);\n        const status = await this.upgrade(basedir);\n        const lock2 = await readFileString(`${basedir}/yarn.lock`);\n        if (status == 0 && (cambio || lock1 != lock2)) {\n            await this.install(basedir, { verbose: false });\n        }\n        if (cambio) {\n            await unlink(`${basedir}/${anterior}`);\n        }\n    }\n    static async getPath(basedir) {\n        const data = await readFileString(`${basedir}/.yarnrc.yml`);\n        return data.split(\"yarnPath:\").at(1)?.trim() ?? \"0.0.0\";\n    }\n    static async updateBase(basedir) {\n        console.log(Colors.colorize([Colors.FgWhite], \"Versión de Yarn\"));\n        console.group();\n        const anterior = await this.getPath(basedir);\n        const { status, stderr } = await Comando.spawn(\"yarn\", [\"set\", \"version\", \"latest\"], { cwd: basedir });\n        if (status != 0) {\n            console.error(Colors.colorize([Colors.FgRed, Colors.Bright], \"ERROR\"));\n            console.error(stderr);\n            console.groupEnd();\n            return Promise.reject();\n        }\n        const nueva = await this.getPath(basedir);\n        const version = nueva.split(\"/\").at(-1)?.split(\"-\").at(-1)?.split(\".\").slice(0, 3).join(\".\") ?? \"0.0.0\";\n        if (anterior != nueva) {\n            console.log(`${Colors.colorize([Colors.FgGreen], version)} (Nueva versión)`);\n        }\n        else {\n            console.log(`${Colors.colorize([Colors.FgBlue], version)} (Sin cambios)`);\n        }\n        console.groupEnd();\n        return { anterior, nueva };\n    }\n    // private static async updatePlugin(basedir: string, plugin: string): Promise<void> {\n    //     const color = Colors.nextColor();\n    //     console.log(Colors.colorize([Colors.FgWhite], \"Instalando plugin\"), Colors.colorize(color, plugin));\n    //     const {status, stdout, stderr} = await Comando.spawn(\"yarn\", [\"plugin\", \"import\", plugin], {cwd: basedir});\n    //     if (status!=0) {\n    //         console.log(Colors.colorize([Colors.FgWhite], \"Instalando plugin\"), Colors.colorize(color, plugin), \"=>\", `[${Colors.colorize([Colors.FgRed], \"ERROR\")}]`);\n    //         return Promise.reject();\n    //     }\n    //     console.log(Colors.colorize([Colors.FgWhite], \"Instalando plugin\"), Colors.colorize(color, plugin), \"=>\", `[${Colors.colorize([Colors.FgGreen], \"OK   \")}]`);\n    // }\n    static async install(basedir, { verbose, install = true, optimize = true } = {}) {\n        // clean ??= false;\n        verbose ??= true;\n        console.log(Colors.colorize([Colors.FgCyan, Colors.Bright], \"Reinstalando dependencias\"));\n        console.group();\n        if (install) {\n            const { status, stdout, stderr } = await Comando.spawn(\"yarn\", [\"install\"], {\n                cwd: basedir,\n            });\n            if (status != 0) {\n                // if (clean && await isFile(`${basedir}/tmp/yarn.lock`)) {\n                //     console.error(`[${Colors.colorize([Colors.FgRed, Colors.Bright], \"ERROR\")}] => ${Colors.colorize([Colors.FgMagenta, Colors.Bright], \"Rollback\")}`);\n                //     if (await isFile(`${basedir}/yarn.lock`)) {\n                //         await unlink(`${basedir}/yarn.lock`);\n                //     }\n                //     await rename(`${basedir}/tmp/yarn.lock`, `${basedir}/yarn.lock`);\n                //     console.groupEnd();\n                //     return this.install(basedir, {verbose});\n                // }\n                console.error(`[${Colors.colorize([Colors.FgRed, Colors.Bright], \"ERROR\")}]`);\n                console.log(stderr);\n                console.groupEnd();\n                return Promise.reject();\n            }\n            if (verbose) {\n                console.log(stdout);\n            }\n        }\n        if (optimize) {\n            console.log(\"Optimizando dependencias\");\n            const { status, stdout } = await Comando.spawn(\"yarn\", [\"dedupe\", \"--strategy\", \"highest\"], {\n                cwd: basedir,\n            });\n            if (status == 0) {\n                console.error(`[${Colors.colorize([Colors.FgGreen, Colors.Bright], \"OK   \")}]`);\n            }\n            else {\n                console.error(`[${Colors.colorize([Colors.FgRed, Colors.Bright], \"ERROR\")}]`);\n            }\n            if (verbose) {\n                console.log(stdout);\n            }\n        }\n        console.groupEnd();\n    }\n    static async upgrade(basedir) {\n        console.log(Colors.colorize([Colors.FgCyan, Colors.Bright], \"Actualizando dependencias\"));\n        console.group();\n        return new Promise((resolve) => {\n            spawn(\"yarn\", [\"upgrade-interactive\",], { cwd: basedir, shell: true, stdio: [process.stdin, process.stdout, process.stderr] })\n                .on(\"error\", (err) => {\n                console.error(\"Error actualizando dependencias\", err);\n            })\n                .on(\"close\", (status) => {\n                console.groupEnd();\n                resolve(status ?? 0);\n            });\n        });\n    }\n}\n"],"names":["promisify","pipeline","async","readFileBuffer","file","readFile","readFileString","toString","readJSON","buffer","JSON","parse","e","Promise","reject","isDir","dir","excepcion","stat","isDirectory","isFile","mkdir","recursive","rename","antiguo","nuevo","then","catch","rmdir","path","rm","force","safeWrite","local","data","sobreescribir","rnd","resolve","flag","err","oldPath","newPath","F_OK","exists","unlink","overwrite","ok","md5Dir","salida","push","actual","readdir","name","join","md5DirExec","length","md5","entrada","createHash","update","digest","KUBERNETES","process","env","ESTATICO","worker","id","partes","split","last","pop","undefined","generarEstatico","info","txt","console","warning","warn","error","letras","random","chars","i","charAt","Math","round","Comando","spawn","comando","params","cwd","shell","colores","proceso","FORCE_COLOR","stdio","stdout","on","stderr","status","Yarn","basedir","install","log","colorize","FgCyan","Bright","group","anterior","nueva","this","updateBase","cambio","instalar","resetNext","groupEnd","verbose","lock1","upgrade","lock2","getPath","at","trim","FgWhite","FgRed","version","slice","FgGreen","FgBlue","optimize","stdin"],"sourceRoot":""}